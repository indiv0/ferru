use std::collections::HashMap;

use post::Post;

#[export]
post -> Post
    = header:header eol content:astring
    { Post::new(header, content) }

// TODO: Look into replacing the Strings with slices.
#[export]
header -> HashMap<String, String>
    = fields:(field:header_field eol? { field })*
    {
        let mut map = HashMap::new();
        for &(k, v) in fields.iter() {
            map.insert(k.to_string(), v.to_string());
        }
        map
    }

header_field -> (&'input str, &'input str)
    = key:string ": " value:string
    { (key, value) }

astring -> &'input str
    = .*
    { match_str}

string -> &'input str
    = (letter / digit / "_" / "-")+
    { match_str }

eolEscapeSequence -> char
    = "\\" eol:eol { '\n' }

digit
    = [0-9]

hexDigit
    = [0-9a-fA-F]

character
    = !(eolChar) .

letter
    = lowerCaseLetter
    / upperCaseLetter

lowerCaseLetter
    = [a-z]

upperCaseLetter
    = [A-Z]

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
    = singleLineComment
    / multiLineComment

singleLineComment
    = "//" (!eolChar .)*

multiLineComment
    = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
    = "\n"
    / "\r\n"
    / "\r"
    / "\u2028"
    / "\u2029"

eolChar
    = [\n\r\u2028\u2029]
    /* Modeled after ECMA-262, 5th ed., 7.2. */

whitespace
    = [ \t\u00A0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000] // \v\f removed
